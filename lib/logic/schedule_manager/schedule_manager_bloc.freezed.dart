// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'schedule_manager_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ScheduleManagerEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Lecturer lecturer) setLecturer,
    required TResult Function(String id) updateLecturer,
    required TResult Function(Schedule schedule) setSchedule,
    required TResult Function((ScheduleType, String) schedule) removeSchedule,
    required TResult Function() clear,
    required TResult Function(String id) updateSchedule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(Lecturer lecturer)? setLecturer,
    TResult? Function(String id)? updateLecturer,
    TResult? Function(Schedule schedule)? setSchedule,
    TResult? Function((ScheduleType, String) schedule)? removeSchedule,
    TResult? Function()? clear,
    TResult? Function(String id)? updateSchedule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Lecturer lecturer)? setLecturer,
    TResult Function(String id)? updateLecturer,
    TResult Function(Schedule schedule)? setSchedule,
    TResult Function((ScheduleType, String) schedule)? removeSchedule,
    TResult Function()? clear,
    TResult Function(String id)? updateSchedule,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SetLecturer value) setLecturer,
    required TResult Function(_UpdateLecturer value) updateLecturer,
    required TResult Function(_SetSchedule value) setSchedule,
    required TResult Function(_RemoveSchedule value) removeSchedule,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UpdateSchedule value) updateSchedule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SetLecturer value)? setLecturer,
    TResult? Function(_UpdateLecturer value)? updateLecturer,
    TResult? Function(_SetSchedule value)? setSchedule,
    TResult? Function(_RemoveSchedule value)? removeSchedule,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SetLecturer value)? setLecturer,
    TResult Function(_UpdateLecturer value)? updateLecturer,
    TResult Function(_SetSchedule value)? setSchedule,
    TResult Function(_RemoveSchedule value)? removeSchedule,
    TResult Function(_Clear value)? clear,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ScheduleManagerEventCopyWith<$Res> {
  factory $ScheduleManagerEventCopyWith(ScheduleManagerEvent value,
          $Res Function(ScheduleManagerEvent) then) =
      _$ScheduleManagerEventCopyWithImpl<$Res, ScheduleManagerEvent>;
}

/// @nodoc
class _$ScheduleManagerEventCopyWithImpl<$Res,
        $Val extends ScheduleManagerEvent>
    implements $ScheduleManagerEventCopyWith<$Res> {
  _$ScheduleManagerEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitImplCopyWith<$Res> {
  factory _$$InitImplCopyWith(
          _$InitImpl value, $Res Function(_$InitImpl) then) =
      __$$InitImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitImplCopyWithImpl<$Res>
    extends _$ScheduleManagerEventCopyWithImpl<$Res, _$InitImpl>
    implements _$$InitImplCopyWith<$Res> {
  __$$InitImplCopyWithImpl(_$InitImpl _value, $Res Function(_$InitImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitImpl with DiagnosticableTreeMixin implements _Init {
  const _$InitImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerEvent.init()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ScheduleManagerEvent.init'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Lecturer lecturer) setLecturer,
    required TResult Function(String id) updateLecturer,
    required TResult Function(Schedule schedule) setSchedule,
    required TResult Function((ScheduleType, String) schedule) removeSchedule,
    required TResult Function() clear,
    required TResult Function(String id) updateSchedule,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(Lecturer lecturer)? setLecturer,
    TResult? Function(String id)? updateLecturer,
    TResult? Function(Schedule schedule)? setSchedule,
    TResult? Function((ScheduleType, String) schedule)? removeSchedule,
    TResult? Function()? clear,
    TResult? Function(String id)? updateSchedule,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Lecturer lecturer)? setLecturer,
    TResult Function(String id)? updateLecturer,
    TResult Function(Schedule schedule)? setSchedule,
    TResult Function((ScheduleType, String) schedule)? removeSchedule,
    TResult Function()? clear,
    TResult Function(String id)? updateSchedule,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SetLecturer value) setLecturer,
    required TResult Function(_UpdateLecturer value) updateLecturer,
    required TResult Function(_SetSchedule value) setSchedule,
    required TResult Function(_RemoveSchedule value) removeSchedule,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UpdateSchedule value) updateSchedule,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SetLecturer value)? setLecturer,
    TResult? Function(_UpdateLecturer value)? updateLecturer,
    TResult? Function(_SetSchedule value)? setSchedule,
    TResult? Function(_RemoveSchedule value)? removeSchedule,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SetLecturer value)? setLecturer,
    TResult Function(_UpdateLecturer value)? updateLecturer,
    TResult Function(_SetSchedule value)? setSchedule,
    TResult Function(_RemoveSchedule value)? removeSchedule,
    TResult Function(_Clear value)? clear,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class _Init implements ScheduleManagerEvent {
  const factory _Init() = _$InitImpl;
}

/// @nodoc
abstract class _$$SetLecturerImplCopyWith<$Res> {
  factory _$$SetLecturerImplCopyWith(
          _$SetLecturerImpl value, $Res Function(_$SetLecturerImpl) then) =
      __$$SetLecturerImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Lecturer lecturer});

  $LecturerCopyWith<$Res> get lecturer;
}

/// @nodoc
class __$$SetLecturerImplCopyWithImpl<$Res>
    extends _$ScheduleManagerEventCopyWithImpl<$Res, _$SetLecturerImpl>
    implements _$$SetLecturerImplCopyWith<$Res> {
  __$$SetLecturerImplCopyWithImpl(
      _$SetLecturerImpl _value, $Res Function(_$SetLecturerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? lecturer = null,
  }) {
    return _then(_$SetLecturerImpl(
      null == lecturer
          ? _value.lecturer
          : lecturer // ignore: cast_nullable_to_non_nullable
              as Lecturer,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LecturerCopyWith<$Res> get lecturer {
    return $LecturerCopyWith<$Res>(_value.lecturer, (value) {
      return _then(_value.copyWith(lecturer: value));
    });
  }
}

/// @nodoc

class _$SetLecturerImpl with DiagnosticableTreeMixin implements _SetLecturer {
  const _$SetLecturerImpl(this.lecturer);

  @override
  final Lecturer lecturer;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerEvent.setLecturer(lecturer: $lecturer)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScheduleManagerEvent.setLecturer'))
      ..add(DiagnosticsProperty('lecturer', lecturer));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SetLecturerImpl &&
            (identical(other.lecturer, lecturer) ||
                other.lecturer == lecturer));
  }

  @override
  int get hashCode => Object.hash(runtimeType, lecturer);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SetLecturerImplCopyWith<_$SetLecturerImpl> get copyWith =>
      __$$SetLecturerImplCopyWithImpl<_$SetLecturerImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Lecturer lecturer) setLecturer,
    required TResult Function(String id) updateLecturer,
    required TResult Function(Schedule schedule) setSchedule,
    required TResult Function((ScheduleType, String) schedule) removeSchedule,
    required TResult Function() clear,
    required TResult Function(String id) updateSchedule,
  }) {
    return setLecturer(lecturer);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(Lecturer lecturer)? setLecturer,
    TResult? Function(String id)? updateLecturer,
    TResult? Function(Schedule schedule)? setSchedule,
    TResult? Function((ScheduleType, String) schedule)? removeSchedule,
    TResult? Function()? clear,
    TResult? Function(String id)? updateSchedule,
  }) {
    return setLecturer?.call(lecturer);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Lecturer lecturer)? setLecturer,
    TResult Function(String id)? updateLecturer,
    TResult Function(Schedule schedule)? setSchedule,
    TResult Function((ScheduleType, String) schedule)? removeSchedule,
    TResult Function()? clear,
    TResult Function(String id)? updateSchedule,
    required TResult orElse(),
  }) {
    if (setLecturer != null) {
      return setLecturer(lecturer);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SetLecturer value) setLecturer,
    required TResult Function(_UpdateLecturer value) updateLecturer,
    required TResult Function(_SetSchedule value) setSchedule,
    required TResult Function(_RemoveSchedule value) removeSchedule,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UpdateSchedule value) updateSchedule,
  }) {
    return setLecturer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SetLecturer value)? setLecturer,
    TResult? Function(_UpdateLecturer value)? updateLecturer,
    TResult? Function(_SetSchedule value)? setSchedule,
    TResult? Function(_RemoveSchedule value)? removeSchedule,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
  }) {
    return setLecturer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SetLecturer value)? setLecturer,
    TResult Function(_UpdateLecturer value)? updateLecturer,
    TResult Function(_SetSchedule value)? setSchedule,
    TResult Function(_RemoveSchedule value)? removeSchedule,
    TResult Function(_Clear value)? clear,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    required TResult orElse(),
  }) {
    if (setLecturer != null) {
      return setLecturer(this);
    }
    return orElse();
  }
}

abstract class _SetLecturer implements ScheduleManagerEvent {
  const factory _SetLecturer(final Lecturer lecturer) = _$SetLecturerImpl;

  Lecturer get lecturer;
  @JsonKey(ignore: true)
  _$$SetLecturerImplCopyWith<_$SetLecturerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateLecturerImplCopyWith<$Res> {
  factory _$$UpdateLecturerImplCopyWith(_$UpdateLecturerImpl value,
          $Res Function(_$UpdateLecturerImpl) then) =
      __$$UpdateLecturerImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String id});
}

/// @nodoc
class __$$UpdateLecturerImplCopyWithImpl<$Res>
    extends _$ScheduleManagerEventCopyWithImpl<$Res, _$UpdateLecturerImpl>
    implements _$$UpdateLecturerImplCopyWith<$Res> {
  __$$UpdateLecturerImplCopyWithImpl(
      _$UpdateLecturerImpl _value, $Res Function(_$UpdateLecturerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_$UpdateLecturerImpl(
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UpdateLecturerImpl
    with DiagnosticableTreeMixin
    implements _UpdateLecturer {
  const _$UpdateLecturerImpl(this.id);

  @override
  final String id;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerEvent.updateLecturer(id: $id)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScheduleManagerEvent.updateLecturer'))
      ..add(DiagnosticsProperty('id', id));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateLecturerImpl &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateLecturerImplCopyWith<_$UpdateLecturerImpl> get copyWith =>
      __$$UpdateLecturerImplCopyWithImpl<_$UpdateLecturerImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Lecturer lecturer) setLecturer,
    required TResult Function(String id) updateLecturer,
    required TResult Function(Schedule schedule) setSchedule,
    required TResult Function((ScheduleType, String) schedule) removeSchedule,
    required TResult Function() clear,
    required TResult Function(String id) updateSchedule,
  }) {
    return updateLecturer(id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(Lecturer lecturer)? setLecturer,
    TResult? Function(String id)? updateLecturer,
    TResult? Function(Schedule schedule)? setSchedule,
    TResult? Function((ScheduleType, String) schedule)? removeSchedule,
    TResult? Function()? clear,
    TResult? Function(String id)? updateSchedule,
  }) {
    return updateLecturer?.call(id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Lecturer lecturer)? setLecturer,
    TResult Function(String id)? updateLecturer,
    TResult Function(Schedule schedule)? setSchedule,
    TResult Function((ScheduleType, String) schedule)? removeSchedule,
    TResult Function()? clear,
    TResult Function(String id)? updateSchedule,
    required TResult orElse(),
  }) {
    if (updateLecturer != null) {
      return updateLecturer(id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SetLecturer value) setLecturer,
    required TResult Function(_UpdateLecturer value) updateLecturer,
    required TResult Function(_SetSchedule value) setSchedule,
    required TResult Function(_RemoveSchedule value) removeSchedule,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UpdateSchedule value) updateSchedule,
  }) {
    return updateLecturer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SetLecturer value)? setLecturer,
    TResult? Function(_UpdateLecturer value)? updateLecturer,
    TResult? Function(_SetSchedule value)? setSchedule,
    TResult? Function(_RemoveSchedule value)? removeSchedule,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
  }) {
    return updateLecturer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SetLecturer value)? setLecturer,
    TResult Function(_UpdateLecturer value)? updateLecturer,
    TResult Function(_SetSchedule value)? setSchedule,
    TResult Function(_RemoveSchedule value)? removeSchedule,
    TResult Function(_Clear value)? clear,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    required TResult orElse(),
  }) {
    if (updateLecturer != null) {
      return updateLecturer(this);
    }
    return orElse();
  }
}

abstract class _UpdateLecturer implements ScheduleManagerEvent {
  const factory _UpdateLecturer(final String id) = _$UpdateLecturerImpl;

  String get id;
  @JsonKey(ignore: true)
  _$$UpdateLecturerImplCopyWith<_$UpdateLecturerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SetScheduleImplCopyWith<$Res> {
  factory _$$SetScheduleImplCopyWith(
          _$SetScheduleImpl value, $Res Function(_$SetScheduleImpl) then) =
      __$$SetScheduleImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Schedule schedule});

  $ScheduleCopyWith<$Res> get schedule;
}

/// @nodoc
class __$$SetScheduleImplCopyWithImpl<$Res>
    extends _$ScheduleManagerEventCopyWithImpl<$Res, _$SetScheduleImpl>
    implements _$$SetScheduleImplCopyWith<$Res> {
  __$$SetScheduleImplCopyWithImpl(
      _$SetScheduleImpl _value, $Res Function(_$SetScheduleImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? schedule = null,
  }) {
    return _then(_$SetScheduleImpl(
      null == schedule
          ? _value.schedule
          : schedule // ignore: cast_nullable_to_non_nullable
              as Schedule,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ScheduleCopyWith<$Res> get schedule {
    return $ScheduleCopyWith<$Res>(_value.schedule, (value) {
      return _then(_value.copyWith(schedule: value));
    });
  }
}

/// @nodoc

class _$SetScheduleImpl with DiagnosticableTreeMixin implements _SetSchedule {
  const _$SetScheduleImpl(this.schedule);

  @override
  final Schedule schedule;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerEvent.setSchedule(schedule: $schedule)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScheduleManagerEvent.setSchedule'))
      ..add(DiagnosticsProperty('schedule', schedule));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SetScheduleImpl &&
            (identical(other.schedule, schedule) ||
                other.schedule == schedule));
  }

  @override
  int get hashCode => Object.hash(runtimeType, schedule);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SetScheduleImplCopyWith<_$SetScheduleImpl> get copyWith =>
      __$$SetScheduleImplCopyWithImpl<_$SetScheduleImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Lecturer lecturer) setLecturer,
    required TResult Function(String id) updateLecturer,
    required TResult Function(Schedule schedule) setSchedule,
    required TResult Function((ScheduleType, String) schedule) removeSchedule,
    required TResult Function() clear,
    required TResult Function(String id) updateSchedule,
  }) {
    return setSchedule(schedule);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(Lecturer lecturer)? setLecturer,
    TResult? Function(String id)? updateLecturer,
    TResult? Function(Schedule schedule)? setSchedule,
    TResult? Function((ScheduleType, String) schedule)? removeSchedule,
    TResult? Function()? clear,
    TResult? Function(String id)? updateSchedule,
  }) {
    return setSchedule?.call(schedule);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Lecturer lecturer)? setLecturer,
    TResult Function(String id)? updateLecturer,
    TResult Function(Schedule schedule)? setSchedule,
    TResult Function((ScheduleType, String) schedule)? removeSchedule,
    TResult Function()? clear,
    TResult Function(String id)? updateSchedule,
    required TResult orElse(),
  }) {
    if (setSchedule != null) {
      return setSchedule(schedule);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SetLecturer value) setLecturer,
    required TResult Function(_UpdateLecturer value) updateLecturer,
    required TResult Function(_SetSchedule value) setSchedule,
    required TResult Function(_RemoveSchedule value) removeSchedule,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UpdateSchedule value) updateSchedule,
  }) {
    return setSchedule(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SetLecturer value)? setLecturer,
    TResult? Function(_UpdateLecturer value)? updateLecturer,
    TResult? Function(_SetSchedule value)? setSchedule,
    TResult? Function(_RemoveSchedule value)? removeSchedule,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
  }) {
    return setSchedule?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SetLecturer value)? setLecturer,
    TResult Function(_UpdateLecturer value)? updateLecturer,
    TResult Function(_SetSchedule value)? setSchedule,
    TResult Function(_RemoveSchedule value)? removeSchedule,
    TResult Function(_Clear value)? clear,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    required TResult orElse(),
  }) {
    if (setSchedule != null) {
      return setSchedule(this);
    }
    return orElse();
  }
}

abstract class _SetSchedule implements ScheduleManagerEvent {
  const factory _SetSchedule(final Schedule schedule) = _$SetScheduleImpl;

  Schedule get schedule;
  @JsonKey(ignore: true)
  _$$SetScheduleImplCopyWith<_$SetScheduleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RemoveScheduleImplCopyWith<$Res> {
  factory _$$RemoveScheduleImplCopyWith(_$RemoveScheduleImpl value,
          $Res Function(_$RemoveScheduleImpl) then) =
      __$$RemoveScheduleImplCopyWithImpl<$Res>;
  @useResult
  $Res call({(ScheduleType, String) schedule});
}

/// @nodoc
class __$$RemoveScheduleImplCopyWithImpl<$Res>
    extends _$ScheduleManagerEventCopyWithImpl<$Res, _$RemoveScheduleImpl>
    implements _$$RemoveScheduleImplCopyWith<$Res> {
  __$$RemoveScheduleImplCopyWithImpl(
      _$RemoveScheduleImpl _value, $Res Function(_$RemoveScheduleImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? schedule = null,
  }) {
    return _then(_$RemoveScheduleImpl(
      null == schedule
          ? _value.schedule
          : schedule // ignore: cast_nullable_to_non_nullable
              as (ScheduleType, String),
    ));
  }
}

/// @nodoc

class _$RemoveScheduleImpl
    with DiagnosticableTreeMixin
    implements _RemoveSchedule {
  const _$RemoveScheduleImpl(this.schedule);

  @override
  final (ScheduleType, String) schedule;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerEvent.removeSchedule(schedule: $schedule)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScheduleManagerEvent.removeSchedule'))
      ..add(DiagnosticsProperty('schedule', schedule));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RemoveScheduleImpl &&
            (identical(other.schedule, schedule) ||
                other.schedule == schedule));
  }

  @override
  int get hashCode => Object.hash(runtimeType, schedule);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RemoveScheduleImplCopyWith<_$RemoveScheduleImpl> get copyWith =>
      __$$RemoveScheduleImplCopyWithImpl<_$RemoveScheduleImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Lecturer lecturer) setLecturer,
    required TResult Function(String id) updateLecturer,
    required TResult Function(Schedule schedule) setSchedule,
    required TResult Function((ScheduleType, String) schedule) removeSchedule,
    required TResult Function() clear,
    required TResult Function(String id) updateSchedule,
  }) {
    return removeSchedule(schedule);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(Lecturer lecturer)? setLecturer,
    TResult? Function(String id)? updateLecturer,
    TResult? Function(Schedule schedule)? setSchedule,
    TResult? Function((ScheduleType, String) schedule)? removeSchedule,
    TResult? Function()? clear,
    TResult? Function(String id)? updateSchedule,
  }) {
    return removeSchedule?.call(schedule);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Lecturer lecturer)? setLecturer,
    TResult Function(String id)? updateLecturer,
    TResult Function(Schedule schedule)? setSchedule,
    TResult Function((ScheduleType, String) schedule)? removeSchedule,
    TResult Function()? clear,
    TResult Function(String id)? updateSchedule,
    required TResult orElse(),
  }) {
    if (removeSchedule != null) {
      return removeSchedule(schedule);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SetLecturer value) setLecturer,
    required TResult Function(_UpdateLecturer value) updateLecturer,
    required TResult Function(_SetSchedule value) setSchedule,
    required TResult Function(_RemoveSchedule value) removeSchedule,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UpdateSchedule value) updateSchedule,
  }) {
    return removeSchedule(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SetLecturer value)? setLecturer,
    TResult? Function(_UpdateLecturer value)? updateLecturer,
    TResult? Function(_SetSchedule value)? setSchedule,
    TResult? Function(_RemoveSchedule value)? removeSchedule,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
  }) {
    return removeSchedule?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SetLecturer value)? setLecturer,
    TResult Function(_UpdateLecturer value)? updateLecturer,
    TResult Function(_SetSchedule value)? setSchedule,
    TResult Function(_RemoveSchedule value)? removeSchedule,
    TResult Function(_Clear value)? clear,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    required TResult orElse(),
  }) {
    if (removeSchedule != null) {
      return removeSchedule(this);
    }
    return orElse();
  }
}

abstract class _RemoveSchedule implements ScheduleManagerEvent {
  const factory _RemoveSchedule(final (ScheduleType, String) schedule) =
      _$RemoveScheduleImpl;

  (ScheduleType, String) get schedule;
  @JsonKey(ignore: true)
  _$$RemoveScheduleImplCopyWith<_$RemoveScheduleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ClearImplCopyWith<$Res> {
  factory _$$ClearImplCopyWith(
          _$ClearImpl value, $Res Function(_$ClearImpl) then) =
      __$$ClearImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClearImplCopyWithImpl<$Res>
    extends _$ScheduleManagerEventCopyWithImpl<$Res, _$ClearImpl>
    implements _$$ClearImplCopyWith<$Res> {
  __$$ClearImplCopyWithImpl(
      _$ClearImpl _value, $Res Function(_$ClearImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ClearImpl with DiagnosticableTreeMixin implements _Clear {
  const _$ClearImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerEvent.clear()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ScheduleManagerEvent.clear'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ClearImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Lecturer lecturer) setLecturer,
    required TResult Function(String id) updateLecturer,
    required TResult Function(Schedule schedule) setSchedule,
    required TResult Function((ScheduleType, String) schedule) removeSchedule,
    required TResult Function() clear,
    required TResult Function(String id) updateSchedule,
  }) {
    return clear();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(Lecturer lecturer)? setLecturer,
    TResult? Function(String id)? updateLecturer,
    TResult? Function(Schedule schedule)? setSchedule,
    TResult? Function((ScheduleType, String) schedule)? removeSchedule,
    TResult? Function()? clear,
    TResult? Function(String id)? updateSchedule,
  }) {
    return clear?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Lecturer lecturer)? setLecturer,
    TResult Function(String id)? updateLecturer,
    TResult Function(Schedule schedule)? setSchedule,
    TResult Function((ScheduleType, String) schedule)? removeSchedule,
    TResult Function()? clear,
    TResult Function(String id)? updateSchedule,
    required TResult orElse(),
  }) {
    if (clear != null) {
      return clear();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SetLecturer value) setLecturer,
    required TResult Function(_UpdateLecturer value) updateLecturer,
    required TResult Function(_SetSchedule value) setSchedule,
    required TResult Function(_RemoveSchedule value) removeSchedule,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UpdateSchedule value) updateSchedule,
  }) {
    return clear(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SetLecturer value)? setLecturer,
    TResult? Function(_UpdateLecturer value)? updateLecturer,
    TResult? Function(_SetSchedule value)? setSchedule,
    TResult? Function(_RemoveSchedule value)? removeSchedule,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
  }) {
    return clear?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SetLecturer value)? setLecturer,
    TResult Function(_UpdateLecturer value)? updateLecturer,
    TResult Function(_SetSchedule value)? setSchedule,
    TResult Function(_RemoveSchedule value)? removeSchedule,
    TResult Function(_Clear value)? clear,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    required TResult orElse(),
  }) {
    if (clear != null) {
      return clear(this);
    }
    return orElse();
  }
}

abstract class _Clear implements ScheduleManagerEvent {
  const factory _Clear() = _$ClearImpl;
}

/// @nodoc
abstract class _$$UpdateScheduleImplCopyWith<$Res> {
  factory _$$UpdateScheduleImplCopyWith(_$UpdateScheduleImpl value,
          $Res Function(_$UpdateScheduleImpl) then) =
      __$$UpdateScheduleImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String id});
}

/// @nodoc
class __$$UpdateScheduleImplCopyWithImpl<$Res>
    extends _$ScheduleManagerEventCopyWithImpl<$Res, _$UpdateScheduleImpl>
    implements _$$UpdateScheduleImplCopyWith<$Res> {
  __$$UpdateScheduleImplCopyWithImpl(
      _$UpdateScheduleImpl _value, $Res Function(_$UpdateScheduleImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_$UpdateScheduleImpl(
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UpdateScheduleImpl
    with DiagnosticableTreeMixin
    implements _UpdateSchedule {
  const _$UpdateScheduleImpl(this.id);

  @override
  final String id;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerEvent.updateSchedule(id: $id)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScheduleManagerEvent.updateSchedule'))
      ..add(DiagnosticsProperty('id', id));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateScheduleImpl &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateScheduleImplCopyWith<_$UpdateScheduleImpl> get copyWith =>
      __$$UpdateScheduleImplCopyWithImpl<_$UpdateScheduleImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Lecturer lecturer) setLecturer,
    required TResult Function(String id) updateLecturer,
    required TResult Function(Schedule schedule) setSchedule,
    required TResult Function((ScheduleType, String) schedule) removeSchedule,
    required TResult Function() clear,
    required TResult Function(String id) updateSchedule,
  }) {
    return updateSchedule(id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(Lecturer lecturer)? setLecturer,
    TResult? Function(String id)? updateLecturer,
    TResult? Function(Schedule schedule)? setSchedule,
    TResult? Function((ScheduleType, String) schedule)? removeSchedule,
    TResult? Function()? clear,
    TResult? Function(String id)? updateSchedule,
  }) {
    return updateSchedule?.call(id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Lecturer lecturer)? setLecturer,
    TResult Function(String id)? updateLecturer,
    TResult Function(Schedule schedule)? setSchedule,
    TResult Function((ScheduleType, String) schedule)? removeSchedule,
    TResult Function()? clear,
    TResult Function(String id)? updateSchedule,
    required TResult orElse(),
  }) {
    if (updateSchedule != null) {
      return updateSchedule(id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SetLecturer value) setLecturer,
    required TResult Function(_UpdateLecturer value) updateLecturer,
    required TResult Function(_SetSchedule value) setSchedule,
    required TResult Function(_RemoveSchedule value) removeSchedule,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UpdateSchedule value) updateSchedule,
  }) {
    return updateSchedule(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SetLecturer value)? setLecturer,
    TResult? Function(_UpdateLecturer value)? updateLecturer,
    TResult? Function(_SetSchedule value)? setSchedule,
    TResult? Function(_RemoveSchedule value)? removeSchedule,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
  }) {
    return updateSchedule?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SetLecturer value)? setLecturer,
    TResult Function(_UpdateLecturer value)? updateLecturer,
    TResult Function(_SetSchedule value)? setSchedule,
    TResult Function(_RemoveSchedule value)? removeSchedule,
    TResult Function(_Clear value)? clear,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    required TResult orElse(),
  }) {
    if (updateSchedule != null) {
      return updateSchedule(this);
    }
    return orElse();
  }
}

abstract class _UpdateSchedule implements ScheduleManagerEvent {
  const factory _UpdateSchedule(final String id) = _$UpdateScheduleImpl;

  String get id;
  @JsonKey(ignore: true)
  _$$UpdateScheduleImplCopyWith<_$UpdateScheduleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ScheduleManagerState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            @HiveField(0, defaultValue: {})
            Map<(ScheduleType, String), ExtendedSchedule> schedules)
        loaded,
    required TResult Function(Set<(ScheduleType, String)> loading) loading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            @HiveField(0, defaultValue: {})
            Map<(ScheduleType, String), ExtendedSchedule> schedules)?
        loaded,
    TResult? Function(Set<(ScheduleType, String)> loading)? loading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            @HiveField(0, defaultValue: {})
            Map<(ScheduleType, String), ExtendedSchedule> schedules)?
        loaded,
    TResult Function(Set<(ScheduleType, String)> loading)? loading,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Loading value) loading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Loading value)? loading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Loading value)? loading,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ScheduleManagerStateCopyWith<$Res> {
  factory $ScheduleManagerStateCopyWith(ScheduleManagerState value,
          $Res Function(ScheduleManagerState) then) =
      _$ScheduleManagerStateCopyWithImpl<$Res, ScheduleManagerState>;
}

/// @nodoc
class _$ScheduleManagerStateCopyWithImpl<$Res,
        $Val extends ScheduleManagerState>
    implements $ScheduleManagerStateCopyWith<$Res> {
  _$ScheduleManagerStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LoadedImplCopyWith<$Res> {
  factory _$$LoadedImplCopyWith(
          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =
      __$$LoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {@HiveField(0, defaultValue: {})
      Map<(ScheduleType, String), ExtendedSchedule> schedules});
}

/// @nodoc
class __$$LoadedImplCopyWithImpl<$Res>
    extends _$ScheduleManagerStateCopyWithImpl<$Res, _$LoadedImpl>
    implements _$$LoadedImplCopyWith<$Res> {
  __$$LoadedImplCopyWithImpl(
      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? schedules = null,
  }) {
    return _then(_$LoadedImpl(
      schedules: null == schedules
          ? _value._schedules
          : schedules // ignore: cast_nullable_to_non_nullable
              as Map<(ScheduleType, String), ExtendedSchedule>,
    ));
  }
}

/// @nodoc

@HiveType(
    typeId: HiveTypeIds.scheduleManagerLoadedState,
    adapterName: "ScheduleManagerStateLoadedAdapter")
class _$LoadedImpl extends _Loaded with DiagnosticableTreeMixin {
  _$LoadedImpl(
      {@HiveField(0, defaultValue: {})
      final Map<(ScheduleType, String), ExtendedSchedule> schedules = const {}})
      : _schedules = schedules,
        super._();

  final Map<(ScheduleType, String), ExtendedSchedule> _schedules;
  @override
  @JsonKey()
  @HiveField(0, defaultValue: {})
  Map<(ScheduleType, String), ExtendedSchedule> get schedules {
    if (_schedules is EqualUnmodifiableMapView) return _schedules;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_schedules);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerState.loaded(schedules: $schedules)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScheduleManagerState.loaded'))
      ..add(DiagnosticsProperty('schedules', schedules));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._schedules, _schedules));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_schedules));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            @HiveField(0, defaultValue: {})
            Map<(ScheduleType, String), ExtendedSchedule> schedules)
        loaded,
    required TResult Function(Set<(ScheduleType, String)> loading) loading,
  }) {
    return loaded(schedules);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            @HiveField(0, defaultValue: {})
            Map<(ScheduleType, String), ExtendedSchedule> schedules)?
        loaded,
    TResult? Function(Set<(ScheduleType, String)> loading)? loading,
  }) {
    return loaded?.call(schedules);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            @HiveField(0, defaultValue: {})
            Map<(ScheduleType, String), ExtendedSchedule> schedules)?
        loaded,
    TResult Function(Set<(ScheduleType, String)> loading)? loading,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(schedules);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Loading value) loading,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Loading value)? loading,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Loading value)? loading,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _Loaded extends ScheduleManagerState {
  factory _Loaded(
          {@HiveField(0, defaultValue: {})
          final Map<(ScheduleType, String), ExtendedSchedule> schedules}) =
      _$LoadedImpl;
  _Loaded._() : super._();

  @HiveField(0, defaultValue: {})
  Map<(ScheduleType, String), ExtendedSchedule> get schedules;
  @JsonKey(ignore: true)
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Set<(ScheduleType, String)> loading});
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$ScheduleManagerStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? loading = null,
  }) {
    return _then(_$LoadingImpl(
      loading: null == loading
          ? _value._loading
          : loading // ignore: cast_nullable_to_non_nullable
              as Set<(ScheduleType, String)>,
    ));
  }
}

/// @nodoc

class _$LoadingImpl extends _Loading with DiagnosticableTreeMixin {
  _$LoadingImpl({final Set<(ScheduleType, String)> loading = const {}})
      : _loading = loading,
        super._();

  final Set<(ScheduleType, String)> _loading;
  @override
  @JsonKey()
  Set<(ScheduleType, String)> get loading {
    if (_loading is EqualUnmodifiableSetView) return _loading;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_loading);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerState.loading(loading: $loading)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScheduleManagerState.loading'))
      ..add(DiagnosticsProperty('loading', loading));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadingImpl &&
            const DeepCollectionEquality().equals(other._loading, _loading));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_loading));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadingImplCopyWith<_$LoadingImpl> get copyWith =>
      __$$LoadingImplCopyWithImpl<_$LoadingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            @HiveField(0, defaultValue: {})
            Map<(ScheduleType, String), ExtendedSchedule> schedules)
        loaded,
    required TResult Function(Set<(ScheduleType, String)> loading) loading,
  }) {
    return loading(this.loading);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            @HiveField(0, defaultValue: {})
            Map<(ScheduleType, String), ExtendedSchedule> schedules)?
        loaded,
    TResult? Function(Set<(ScheduleType, String)> loading)? loading,
  }) {
    return loading?.call(this.loading);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            @HiveField(0, defaultValue: {})
            Map<(ScheduleType, String), ExtendedSchedule> schedules)?
        loaded,
    TResult Function(Set<(ScheduleType, String)> loading)? loading,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this.loading);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Loading value) loading,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Loading value)? loading,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Loading value)? loading,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading extends ScheduleManagerState {
  factory _Loading({final Set<(ScheduleType, String)> loading}) = _$LoadingImpl;
  _Loading._() : super._();

  Set<(ScheduleType, String)> get loading;
  @JsonKey(ignore: true)
  _$$LoadingImplCopyWith<_$LoadingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
