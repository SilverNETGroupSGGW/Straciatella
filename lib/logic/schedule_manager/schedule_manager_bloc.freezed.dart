// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'schedule_manager_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ScheduleManagerEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(List<BaseSchedule> index) setIndex,
    required TResult Function() updateIndex,
    required TResult Function(Lecturer lecturer) setLecturer,
    required TResult Function(String id) updateLecturer,
    required TResult Function(Schedule schedule) setSchedule,
    required TResult Function(String id) updateSchedule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(List<BaseSchedule> index)? setIndex,
    TResult? Function()? updateIndex,
    TResult? Function(Lecturer lecturer)? setLecturer,
    TResult? Function(String id)? updateLecturer,
    TResult? Function(Schedule schedule)? setSchedule,
    TResult? Function(String id)? updateSchedule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(List<BaseSchedule> index)? setIndex,
    TResult Function()? updateIndex,
    TResult Function(Lecturer lecturer)? setLecturer,
    TResult Function(String id)? updateLecturer,
    TResult Function(Schedule schedule)? setSchedule,
    TResult Function(String id)? updateSchedule,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SetIndex value) setIndex,
    required TResult Function(_UpdateIndex value) updateIndex,
    required TResult Function(_SetLecturer value) setLecturer,
    required TResult Function(_UpdateLecturer value) updateLecturer,
    required TResult Function(_SetSchedule value) setSchedule,
    required TResult Function(_UpdateSchedule value) updateSchedule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SetIndex value)? setIndex,
    TResult? Function(_UpdateIndex value)? updateIndex,
    TResult? Function(_SetLecturer value)? setLecturer,
    TResult? Function(_UpdateLecturer value)? updateLecturer,
    TResult? Function(_SetSchedule value)? setSchedule,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SetIndex value)? setIndex,
    TResult Function(_UpdateIndex value)? updateIndex,
    TResult Function(_SetLecturer value)? setLecturer,
    TResult Function(_UpdateLecturer value)? updateLecturer,
    TResult Function(_SetSchedule value)? setSchedule,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ScheduleManagerEventCopyWith<$Res> {
  factory $ScheduleManagerEventCopyWith(ScheduleManagerEvent value,
          $Res Function(ScheduleManagerEvent) then) =
      _$ScheduleManagerEventCopyWithImpl<$Res, ScheduleManagerEvent>;
}

/// @nodoc
class _$ScheduleManagerEventCopyWithImpl<$Res,
        $Val extends ScheduleManagerEvent>
    implements $ScheduleManagerEventCopyWith<$Res> {
  _$ScheduleManagerEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitImplCopyWith<$Res> {
  factory _$$InitImplCopyWith(
          _$InitImpl value, $Res Function(_$InitImpl) then) =
      __$$InitImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitImplCopyWithImpl<$Res>
    extends _$ScheduleManagerEventCopyWithImpl<$Res, _$InitImpl>
    implements _$$InitImplCopyWith<$Res> {
  __$$InitImplCopyWithImpl(_$InitImpl _value, $Res Function(_$InitImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitImpl with DiagnosticableTreeMixin implements _Init {
  const _$InitImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerEvent.init()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ScheduleManagerEvent.init'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(List<BaseSchedule> index) setIndex,
    required TResult Function() updateIndex,
    required TResult Function(Lecturer lecturer) setLecturer,
    required TResult Function(String id) updateLecturer,
    required TResult Function(Schedule schedule) setSchedule,
    required TResult Function(String id) updateSchedule,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(List<BaseSchedule> index)? setIndex,
    TResult? Function()? updateIndex,
    TResult? Function(Lecturer lecturer)? setLecturer,
    TResult? Function(String id)? updateLecturer,
    TResult? Function(Schedule schedule)? setSchedule,
    TResult? Function(String id)? updateSchedule,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(List<BaseSchedule> index)? setIndex,
    TResult Function()? updateIndex,
    TResult Function(Lecturer lecturer)? setLecturer,
    TResult Function(String id)? updateLecturer,
    TResult Function(Schedule schedule)? setSchedule,
    TResult Function(String id)? updateSchedule,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SetIndex value) setIndex,
    required TResult Function(_UpdateIndex value) updateIndex,
    required TResult Function(_SetLecturer value) setLecturer,
    required TResult Function(_UpdateLecturer value) updateLecturer,
    required TResult Function(_SetSchedule value) setSchedule,
    required TResult Function(_UpdateSchedule value) updateSchedule,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SetIndex value)? setIndex,
    TResult? Function(_UpdateIndex value)? updateIndex,
    TResult? Function(_SetLecturer value)? setLecturer,
    TResult? Function(_UpdateLecturer value)? updateLecturer,
    TResult? Function(_SetSchedule value)? setSchedule,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SetIndex value)? setIndex,
    TResult Function(_UpdateIndex value)? updateIndex,
    TResult Function(_SetLecturer value)? setLecturer,
    TResult Function(_UpdateLecturer value)? updateLecturer,
    TResult Function(_SetSchedule value)? setSchedule,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class _Init implements ScheduleManagerEvent {
  const factory _Init() = _$InitImpl;
}

/// @nodoc
abstract class _$$SetIndexImplCopyWith<$Res> {
  factory _$$SetIndexImplCopyWith(
          _$SetIndexImpl value, $Res Function(_$SetIndexImpl) then) =
      __$$SetIndexImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<BaseSchedule> index});
}

/// @nodoc
class __$$SetIndexImplCopyWithImpl<$Res>
    extends _$ScheduleManagerEventCopyWithImpl<$Res, _$SetIndexImpl>
    implements _$$SetIndexImplCopyWith<$Res> {
  __$$SetIndexImplCopyWithImpl(
      _$SetIndexImpl _value, $Res Function(_$SetIndexImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$SetIndexImpl(
      null == index
          ? _value._index
          : index // ignore: cast_nullable_to_non_nullable
              as List<BaseSchedule>,
    ));
  }
}

/// @nodoc

class _$SetIndexImpl with DiagnosticableTreeMixin implements _SetIndex {
  const _$SetIndexImpl(final List<BaseSchedule> index) : _index = index;

  final List<BaseSchedule> _index;
  @override
  List<BaseSchedule> get index {
    if (_index is EqualUnmodifiableListView) return _index;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_index);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerEvent.setIndex(index: $index)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScheduleManagerEvent.setIndex'))
      ..add(DiagnosticsProperty('index', index));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SetIndexImpl &&
            const DeepCollectionEquality().equals(other._index, _index));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_index));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SetIndexImplCopyWith<_$SetIndexImpl> get copyWith =>
      __$$SetIndexImplCopyWithImpl<_$SetIndexImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(List<BaseSchedule> index) setIndex,
    required TResult Function() updateIndex,
    required TResult Function(Lecturer lecturer) setLecturer,
    required TResult Function(String id) updateLecturer,
    required TResult Function(Schedule schedule) setSchedule,
    required TResult Function(String id) updateSchedule,
  }) {
    return setIndex(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(List<BaseSchedule> index)? setIndex,
    TResult? Function()? updateIndex,
    TResult? Function(Lecturer lecturer)? setLecturer,
    TResult? Function(String id)? updateLecturer,
    TResult? Function(Schedule schedule)? setSchedule,
    TResult? Function(String id)? updateSchedule,
  }) {
    return setIndex?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(List<BaseSchedule> index)? setIndex,
    TResult Function()? updateIndex,
    TResult Function(Lecturer lecturer)? setLecturer,
    TResult Function(String id)? updateLecturer,
    TResult Function(Schedule schedule)? setSchedule,
    TResult Function(String id)? updateSchedule,
    required TResult orElse(),
  }) {
    if (setIndex != null) {
      return setIndex(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SetIndex value) setIndex,
    required TResult Function(_UpdateIndex value) updateIndex,
    required TResult Function(_SetLecturer value) setLecturer,
    required TResult Function(_UpdateLecturer value) updateLecturer,
    required TResult Function(_SetSchedule value) setSchedule,
    required TResult Function(_UpdateSchedule value) updateSchedule,
  }) {
    return setIndex(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SetIndex value)? setIndex,
    TResult? Function(_UpdateIndex value)? updateIndex,
    TResult? Function(_SetLecturer value)? setLecturer,
    TResult? Function(_UpdateLecturer value)? updateLecturer,
    TResult? Function(_SetSchedule value)? setSchedule,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
  }) {
    return setIndex?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SetIndex value)? setIndex,
    TResult Function(_UpdateIndex value)? updateIndex,
    TResult Function(_SetLecturer value)? setLecturer,
    TResult Function(_UpdateLecturer value)? updateLecturer,
    TResult Function(_SetSchedule value)? setSchedule,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    required TResult orElse(),
  }) {
    if (setIndex != null) {
      return setIndex(this);
    }
    return orElse();
  }
}

abstract class _SetIndex implements ScheduleManagerEvent {
  const factory _SetIndex(final List<BaseSchedule> index) = _$SetIndexImpl;

  List<BaseSchedule> get index;
  @JsonKey(ignore: true)
  _$$SetIndexImplCopyWith<_$SetIndexImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateIndexImplCopyWith<$Res> {
  factory _$$UpdateIndexImplCopyWith(
          _$UpdateIndexImpl value, $Res Function(_$UpdateIndexImpl) then) =
      __$$UpdateIndexImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UpdateIndexImplCopyWithImpl<$Res>
    extends _$ScheduleManagerEventCopyWithImpl<$Res, _$UpdateIndexImpl>
    implements _$$UpdateIndexImplCopyWith<$Res> {
  __$$UpdateIndexImplCopyWithImpl(
      _$UpdateIndexImpl _value, $Res Function(_$UpdateIndexImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UpdateIndexImpl with DiagnosticableTreeMixin implements _UpdateIndex {
  const _$UpdateIndexImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerEvent.updateIndex()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'ScheduleManagerEvent.updateIndex'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UpdateIndexImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(List<BaseSchedule> index) setIndex,
    required TResult Function() updateIndex,
    required TResult Function(Lecturer lecturer) setLecturer,
    required TResult Function(String id) updateLecturer,
    required TResult Function(Schedule schedule) setSchedule,
    required TResult Function(String id) updateSchedule,
  }) {
    return updateIndex();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(List<BaseSchedule> index)? setIndex,
    TResult? Function()? updateIndex,
    TResult? Function(Lecturer lecturer)? setLecturer,
    TResult? Function(String id)? updateLecturer,
    TResult? Function(Schedule schedule)? setSchedule,
    TResult? Function(String id)? updateSchedule,
  }) {
    return updateIndex?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(List<BaseSchedule> index)? setIndex,
    TResult Function()? updateIndex,
    TResult Function(Lecturer lecturer)? setLecturer,
    TResult Function(String id)? updateLecturer,
    TResult Function(Schedule schedule)? setSchedule,
    TResult Function(String id)? updateSchedule,
    required TResult orElse(),
  }) {
    if (updateIndex != null) {
      return updateIndex();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SetIndex value) setIndex,
    required TResult Function(_UpdateIndex value) updateIndex,
    required TResult Function(_SetLecturer value) setLecturer,
    required TResult Function(_UpdateLecturer value) updateLecturer,
    required TResult Function(_SetSchedule value) setSchedule,
    required TResult Function(_UpdateSchedule value) updateSchedule,
  }) {
    return updateIndex(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SetIndex value)? setIndex,
    TResult? Function(_UpdateIndex value)? updateIndex,
    TResult? Function(_SetLecturer value)? setLecturer,
    TResult? Function(_UpdateLecturer value)? updateLecturer,
    TResult? Function(_SetSchedule value)? setSchedule,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
  }) {
    return updateIndex?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SetIndex value)? setIndex,
    TResult Function(_UpdateIndex value)? updateIndex,
    TResult Function(_SetLecturer value)? setLecturer,
    TResult Function(_UpdateLecturer value)? updateLecturer,
    TResult Function(_SetSchedule value)? setSchedule,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    required TResult orElse(),
  }) {
    if (updateIndex != null) {
      return updateIndex(this);
    }
    return orElse();
  }
}

abstract class _UpdateIndex implements ScheduleManagerEvent {
  const factory _UpdateIndex() = _$UpdateIndexImpl;
}

/// @nodoc
abstract class _$$SetLecturerImplCopyWith<$Res> {
  factory _$$SetLecturerImplCopyWith(
          _$SetLecturerImpl value, $Res Function(_$SetLecturerImpl) then) =
      __$$SetLecturerImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Lecturer lecturer});

  $LecturerCopyWith<$Res> get lecturer;
}

/// @nodoc
class __$$SetLecturerImplCopyWithImpl<$Res>
    extends _$ScheduleManagerEventCopyWithImpl<$Res, _$SetLecturerImpl>
    implements _$$SetLecturerImplCopyWith<$Res> {
  __$$SetLecturerImplCopyWithImpl(
      _$SetLecturerImpl _value, $Res Function(_$SetLecturerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? lecturer = null,
  }) {
    return _then(_$SetLecturerImpl(
      null == lecturer
          ? _value.lecturer
          : lecturer // ignore: cast_nullable_to_non_nullable
              as Lecturer,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LecturerCopyWith<$Res> get lecturer {
    return $LecturerCopyWith<$Res>(_value.lecturer, (value) {
      return _then(_value.copyWith(lecturer: value));
    });
  }
}

/// @nodoc

class _$SetLecturerImpl with DiagnosticableTreeMixin implements _SetLecturer {
  const _$SetLecturerImpl(this.lecturer);

  @override
  final Lecturer lecturer;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerEvent.setLecturer(lecturer: $lecturer)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScheduleManagerEvent.setLecturer'))
      ..add(DiagnosticsProperty('lecturer', lecturer));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SetLecturerImpl &&
            (identical(other.lecturer, lecturer) ||
                other.lecturer == lecturer));
  }

  @override
  int get hashCode => Object.hash(runtimeType, lecturer);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SetLecturerImplCopyWith<_$SetLecturerImpl> get copyWith =>
      __$$SetLecturerImplCopyWithImpl<_$SetLecturerImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(List<BaseSchedule> index) setIndex,
    required TResult Function() updateIndex,
    required TResult Function(Lecturer lecturer) setLecturer,
    required TResult Function(String id) updateLecturer,
    required TResult Function(Schedule schedule) setSchedule,
    required TResult Function(String id) updateSchedule,
  }) {
    return setLecturer(lecturer);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(List<BaseSchedule> index)? setIndex,
    TResult? Function()? updateIndex,
    TResult? Function(Lecturer lecturer)? setLecturer,
    TResult? Function(String id)? updateLecturer,
    TResult? Function(Schedule schedule)? setSchedule,
    TResult? Function(String id)? updateSchedule,
  }) {
    return setLecturer?.call(lecturer);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(List<BaseSchedule> index)? setIndex,
    TResult Function()? updateIndex,
    TResult Function(Lecturer lecturer)? setLecturer,
    TResult Function(String id)? updateLecturer,
    TResult Function(Schedule schedule)? setSchedule,
    TResult Function(String id)? updateSchedule,
    required TResult orElse(),
  }) {
    if (setLecturer != null) {
      return setLecturer(lecturer);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SetIndex value) setIndex,
    required TResult Function(_UpdateIndex value) updateIndex,
    required TResult Function(_SetLecturer value) setLecturer,
    required TResult Function(_UpdateLecturer value) updateLecturer,
    required TResult Function(_SetSchedule value) setSchedule,
    required TResult Function(_UpdateSchedule value) updateSchedule,
  }) {
    return setLecturer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SetIndex value)? setIndex,
    TResult? Function(_UpdateIndex value)? updateIndex,
    TResult? Function(_SetLecturer value)? setLecturer,
    TResult? Function(_UpdateLecturer value)? updateLecturer,
    TResult? Function(_SetSchedule value)? setSchedule,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
  }) {
    return setLecturer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SetIndex value)? setIndex,
    TResult Function(_UpdateIndex value)? updateIndex,
    TResult Function(_SetLecturer value)? setLecturer,
    TResult Function(_UpdateLecturer value)? updateLecturer,
    TResult Function(_SetSchedule value)? setSchedule,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    required TResult orElse(),
  }) {
    if (setLecturer != null) {
      return setLecturer(this);
    }
    return orElse();
  }
}

abstract class _SetLecturer implements ScheduleManagerEvent {
  const factory _SetLecturer(final Lecturer lecturer) = _$SetLecturerImpl;

  Lecturer get lecturer;
  @JsonKey(ignore: true)
  _$$SetLecturerImplCopyWith<_$SetLecturerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateLecturerImplCopyWith<$Res> {
  factory _$$UpdateLecturerImplCopyWith(_$UpdateLecturerImpl value,
          $Res Function(_$UpdateLecturerImpl) then) =
      __$$UpdateLecturerImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String id});
}

/// @nodoc
class __$$UpdateLecturerImplCopyWithImpl<$Res>
    extends _$ScheduleManagerEventCopyWithImpl<$Res, _$UpdateLecturerImpl>
    implements _$$UpdateLecturerImplCopyWith<$Res> {
  __$$UpdateLecturerImplCopyWithImpl(
      _$UpdateLecturerImpl _value, $Res Function(_$UpdateLecturerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_$UpdateLecturerImpl(
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UpdateLecturerImpl
    with DiagnosticableTreeMixin
    implements _UpdateLecturer {
  const _$UpdateLecturerImpl(this.id);

  @override
  final String id;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerEvent.updateLecturer(id: $id)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScheduleManagerEvent.updateLecturer'))
      ..add(DiagnosticsProperty('id', id));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateLecturerImpl &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateLecturerImplCopyWith<_$UpdateLecturerImpl> get copyWith =>
      __$$UpdateLecturerImplCopyWithImpl<_$UpdateLecturerImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(List<BaseSchedule> index) setIndex,
    required TResult Function() updateIndex,
    required TResult Function(Lecturer lecturer) setLecturer,
    required TResult Function(String id) updateLecturer,
    required TResult Function(Schedule schedule) setSchedule,
    required TResult Function(String id) updateSchedule,
  }) {
    return updateLecturer(id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(List<BaseSchedule> index)? setIndex,
    TResult? Function()? updateIndex,
    TResult? Function(Lecturer lecturer)? setLecturer,
    TResult? Function(String id)? updateLecturer,
    TResult? Function(Schedule schedule)? setSchedule,
    TResult? Function(String id)? updateSchedule,
  }) {
    return updateLecturer?.call(id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(List<BaseSchedule> index)? setIndex,
    TResult Function()? updateIndex,
    TResult Function(Lecturer lecturer)? setLecturer,
    TResult Function(String id)? updateLecturer,
    TResult Function(Schedule schedule)? setSchedule,
    TResult Function(String id)? updateSchedule,
    required TResult orElse(),
  }) {
    if (updateLecturer != null) {
      return updateLecturer(id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SetIndex value) setIndex,
    required TResult Function(_UpdateIndex value) updateIndex,
    required TResult Function(_SetLecturer value) setLecturer,
    required TResult Function(_UpdateLecturer value) updateLecturer,
    required TResult Function(_SetSchedule value) setSchedule,
    required TResult Function(_UpdateSchedule value) updateSchedule,
  }) {
    return updateLecturer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SetIndex value)? setIndex,
    TResult? Function(_UpdateIndex value)? updateIndex,
    TResult? Function(_SetLecturer value)? setLecturer,
    TResult? Function(_UpdateLecturer value)? updateLecturer,
    TResult? Function(_SetSchedule value)? setSchedule,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
  }) {
    return updateLecturer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SetIndex value)? setIndex,
    TResult Function(_UpdateIndex value)? updateIndex,
    TResult Function(_SetLecturer value)? setLecturer,
    TResult Function(_UpdateLecturer value)? updateLecturer,
    TResult Function(_SetSchedule value)? setSchedule,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    required TResult orElse(),
  }) {
    if (updateLecturer != null) {
      return updateLecturer(this);
    }
    return orElse();
  }
}

abstract class _UpdateLecturer implements ScheduleManagerEvent {
  const factory _UpdateLecturer(final String id) = _$UpdateLecturerImpl;

  String get id;
  @JsonKey(ignore: true)
  _$$UpdateLecturerImplCopyWith<_$UpdateLecturerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SetScheduleImplCopyWith<$Res> {
  factory _$$SetScheduleImplCopyWith(
          _$SetScheduleImpl value, $Res Function(_$SetScheduleImpl) then) =
      __$$SetScheduleImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Schedule schedule});

  $ScheduleCopyWith<$Res> get schedule;
}

/// @nodoc
class __$$SetScheduleImplCopyWithImpl<$Res>
    extends _$ScheduleManagerEventCopyWithImpl<$Res, _$SetScheduleImpl>
    implements _$$SetScheduleImplCopyWith<$Res> {
  __$$SetScheduleImplCopyWithImpl(
      _$SetScheduleImpl _value, $Res Function(_$SetScheduleImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? schedule = null,
  }) {
    return _then(_$SetScheduleImpl(
      null == schedule
          ? _value.schedule
          : schedule // ignore: cast_nullable_to_non_nullable
              as Schedule,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ScheduleCopyWith<$Res> get schedule {
    return $ScheduleCopyWith<$Res>(_value.schedule, (value) {
      return _then(_value.copyWith(schedule: value));
    });
  }
}

/// @nodoc

class _$SetScheduleImpl with DiagnosticableTreeMixin implements _SetSchedule {
  const _$SetScheduleImpl(this.schedule);

  @override
  final Schedule schedule;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerEvent.setSchedule(schedule: $schedule)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScheduleManagerEvent.setSchedule'))
      ..add(DiagnosticsProperty('schedule', schedule));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SetScheduleImpl &&
            (identical(other.schedule, schedule) ||
                other.schedule == schedule));
  }

  @override
  int get hashCode => Object.hash(runtimeType, schedule);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SetScheduleImplCopyWith<_$SetScheduleImpl> get copyWith =>
      __$$SetScheduleImplCopyWithImpl<_$SetScheduleImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(List<BaseSchedule> index) setIndex,
    required TResult Function() updateIndex,
    required TResult Function(Lecturer lecturer) setLecturer,
    required TResult Function(String id) updateLecturer,
    required TResult Function(Schedule schedule) setSchedule,
    required TResult Function(String id) updateSchedule,
  }) {
    return setSchedule(schedule);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(List<BaseSchedule> index)? setIndex,
    TResult? Function()? updateIndex,
    TResult? Function(Lecturer lecturer)? setLecturer,
    TResult? Function(String id)? updateLecturer,
    TResult? Function(Schedule schedule)? setSchedule,
    TResult? Function(String id)? updateSchedule,
  }) {
    return setSchedule?.call(schedule);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(List<BaseSchedule> index)? setIndex,
    TResult Function()? updateIndex,
    TResult Function(Lecturer lecturer)? setLecturer,
    TResult Function(String id)? updateLecturer,
    TResult Function(Schedule schedule)? setSchedule,
    TResult Function(String id)? updateSchedule,
    required TResult orElse(),
  }) {
    if (setSchedule != null) {
      return setSchedule(schedule);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SetIndex value) setIndex,
    required TResult Function(_UpdateIndex value) updateIndex,
    required TResult Function(_SetLecturer value) setLecturer,
    required TResult Function(_UpdateLecturer value) updateLecturer,
    required TResult Function(_SetSchedule value) setSchedule,
    required TResult Function(_UpdateSchedule value) updateSchedule,
  }) {
    return setSchedule(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SetIndex value)? setIndex,
    TResult? Function(_UpdateIndex value)? updateIndex,
    TResult? Function(_SetLecturer value)? setLecturer,
    TResult? Function(_UpdateLecturer value)? updateLecturer,
    TResult? Function(_SetSchedule value)? setSchedule,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
  }) {
    return setSchedule?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SetIndex value)? setIndex,
    TResult Function(_UpdateIndex value)? updateIndex,
    TResult Function(_SetLecturer value)? setLecturer,
    TResult Function(_UpdateLecturer value)? updateLecturer,
    TResult Function(_SetSchedule value)? setSchedule,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    required TResult orElse(),
  }) {
    if (setSchedule != null) {
      return setSchedule(this);
    }
    return orElse();
  }
}

abstract class _SetSchedule implements ScheduleManagerEvent {
  const factory _SetSchedule(final Schedule schedule) = _$SetScheduleImpl;

  Schedule get schedule;
  @JsonKey(ignore: true)
  _$$SetScheduleImplCopyWith<_$SetScheduleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateScheduleImplCopyWith<$Res> {
  factory _$$UpdateScheduleImplCopyWith(_$UpdateScheduleImpl value,
          $Res Function(_$UpdateScheduleImpl) then) =
      __$$UpdateScheduleImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String id});
}

/// @nodoc
class __$$UpdateScheduleImplCopyWithImpl<$Res>
    extends _$ScheduleManagerEventCopyWithImpl<$Res, _$UpdateScheduleImpl>
    implements _$$UpdateScheduleImplCopyWith<$Res> {
  __$$UpdateScheduleImplCopyWithImpl(
      _$UpdateScheduleImpl _value, $Res Function(_$UpdateScheduleImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_$UpdateScheduleImpl(
      null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UpdateScheduleImpl
    with DiagnosticableTreeMixin
    implements _UpdateSchedule {
  const _$UpdateScheduleImpl(this.id);

  @override
  final String id;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerEvent.updateSchedule(id: $id)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScheduleManagerEvent.updateSchedule'))
      ..add(DiagnosticsProperty('id', id));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateScheduleImpl &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateScheduleImplCopyWith<_$UpdateScheduleImpl> get copyWith =>
      __$$UpdateScheduleImplCopyWithImpl<_$UpdateScheduleImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(List<BaseSchedule> index) setIndex,
    required TResult Function() updateIndex,
    required TResult Function(Lecturer lecturer) setLecturer,
    required TResult Function(String id) updateLecturer,
    required TResult Function(Schedule schedule) setSchedule,
    required TResult Function(String id) updateSchedule,
  }) {
    return updateSchedule(id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(List<BaseSchedule> index)? setIndex,
    TResult? Function()? updateIndex,
    TResult? Function(Lecturer lecturer)? setLecturer,
    TResult? Function(String id)? updateLecturer,
    TResult? Function(Schedule schedule)? setSchedule,
    TResult? Function(String id)? updateSchedule,
  }) {
    return updateSchedule?.call(id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(List<BaseSchedule> index)? setIndex,
    TResult Function()? updateIndex,
    TResult Function(Lecturer lecturer)? setLecturer,
    TResult Function(String id)? updateLecturer,
    TResult Function(Schedule schedule)? setSchedule,
    TResult Function(String id)? updateSchedule,
    required TResult orElse(),
  }) {
    if (updateSchedule != null) {
      return updateSchedule(id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SetIndex value) setIndex,
    required TResult Function(_UpdateIndex value) updateIndex,
    required TResult Function(_SetLecturer value) setLecturer,
    required TResult Function(_UpdateLecturer value) updateLecturer,
    required TResult Function(_SetSchedule value) setSchedule,
    required TResult Function(_UpdateSchedule value) updateSchedule,
  }) {
    return updateSchedule(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SetIndex value)? setIndex,
    TResult? Function(_UpdateIndex value)? updateIndex,
    TResult? Function(_SetLecturer value)? setLecturer,
    TResult? Function(_UpdateLecturer value)? updateLecturer,
    TResult? Function(_SetSchedule value)? setSchedule,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
  }) {
    return updateSchedule?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SetIndex value)? setIndex,
    TResult Function(_UpdateIndex value)? updateIndex,
    TResult Function(_SetLecturer value)? setLecturer,
    TResult Function(_UpdateLecturer value)? updateLecturer,
    TResult Function(_SetSchedule value)? setSchedule,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    required TResult orElse(),
  }) {
    if (updateSchedule != null) {
      return updateSchedule(this);
    }
    return orElse();
  }
}

abstract class _UpdateSchedule implements ScheduleManagerEvent {
  const factory _UpdateSchedule(final String id) = _$UpdateScheduleImpl;

  String get id;
  @JsonKey(ignore: true)
  _$$UpdateScheduleImplCopyWith<_$UpdateScheduleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ScheduleManagerState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            @HiveField(0, defaultValue: {})
            Map<(Type, String), BaseSchedule> schedulesIndex,
            @HiveField(1, defaultValue: {})
            Map<(Type, String), ExtendedSchedule> schedules)
        loaded,
    required TResult Function(bool all, Set<(Type, String)> loading) loading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            @HiveField(0, defaultValue: {})
            Map<(Type, String), BaseSchedule> schedulesIndex,
            @HiveField(1, defaultValue: {})
            Map<(Type, String), ExtendedSchedule> schedules)?
        loaded,
    TResult? Function(bool all, Set<(Type, String)> loading)? loading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            @HiveField(0, defaultValue: {})
            Map<(Type, String), BaseSchedule> schedulesIndex,
            @HiveField(1, defaultValue: {})
            Map<(Type, String), ExtendedSchedule> schedules)?
        loaded,
    TResult Function(bool all, Set<(Type, String)> loading)? loading,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Loading value) loading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Loading value)? loading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Loading value)? loading,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ScheduleManagerStateCopyWith<$Res> {
  factory $ScheduleManagerStateCopyWith(ScheduleManagerState value,
          $Res Function(ScheduleManagerState) then) =
      _$ScheduleManagerStateCopyWithImpl<$Res, ScheduleManagerState>;
}

/// @nodoc
class _$ScheduleManagerStateCopyWithImpl<$Res,
        $Val extends ScheduleManagerState>
    implements $ScheduleManagerStateCopyWith<$Res> {
  _$ScheduleManagerStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LoadedImplCopyWith<$Res> {
  factory _$$LoadedImplCopyWith(
          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =
      __$$LoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {@HiveField(0, defaultValue: {})
      Map<(Type, String), BaseSchedule> schedulesIndex,
      @HiveField(1, defaultValue: {})
      Map<(Type, String), ExtendedSchedule> schedules});
}

/// @nodoc
class __$$LoadedImplCopyWithImpl<$Res>
    extends _$ScheduleManagerStateCopyWithImpl<$Res, _$LoadedImpl>
    implements _$$LoadedImplCopyWith<$Res> {
  __$$LoadedImplCopyWithImpl(
      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? schedulesIndex = null,
    Object? schedules = null,
  }) {
    return _then(_$LoadedImpl(
      schedulesIndex: null == schedulesIndex
          ? _value._schedulesIndex
          : schedulesIndex // ignore: cast_nullable_to_non_nullable
              as Map<(Type, String), BaseSchedule>,
      schedules: null == schedules
          ? _value._schedules
          : schedules // ignore: cast_nullable_to_non_nullable
              as Map<(Type, String), ExtendedSchedule>,
    ));
  }
}

/// @nodoc

@HiveType(
    typeId: HiveTypeIds.scheduleManagerLoadedState,
    adapterName: "ScheduleManagerStateLoadedAdapter")
class _$LoadedImpl extends _Loaded with DiagnosticableTreeMixin {
  _$LoadedImpl(
      {@HiveField(0, defaultValue: {})
      final Map<(Type, String), BaseSchedule> schedulesIndex = const {},
      @HiveField(1, defaultValue: {})
      final Map<(Type, String), ExtendedSchedule> schedules = const {}})
      : _schedulesIndex = schedulesIndex,
        _schedules = schedules,
        super._();

  final Map<(Type, String), BaseSchedule> _schedulesIndex;
  @override
  @JsonKey()
  @HiveField(0, defaultValue: {})
  Map<(Type, String), BaseSchedule> get schedulesIndex {
    if (_schedulesIndex is EqualUnmodifiableMapView) return _schedulesIndex;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_schedulesIndex);
  }

  final Map<(Type, String), ExtendedSchedule> _schedules;
  @override
  @JsonKey()
  @HiveField(1, defaultValue: {})
  Map<(Type, String), ExtendedSchedule> get schedules {
    if (_schedules is EqualUnmodifiableMapView) return _schedules;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_schedules);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerState.loaded(schedulesIndex: $schedulesIndex, schedules: $schedules)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScheduleManagerState.loaded'))
      ..add(DiagnosticsProperty('schedulesIndex', schedulesIndex))
      ..add(DiagnosticsProperty('schedules', schedules));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._schedulesIndex, _schedulesIndex) &&
            const DeepCollectionEquality()
                .equals(other._schedules, _schedules));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_schedulesIndex),
      const DeepCollectionEquality().hash(_schedules));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            @HiveField(0, defaultValue: {})
            Map<(Type, String), BaseSchedule> schedulesIndex,
            @HiveField(1, defaultValue: {})
            Map<(Type, String), ExtendedSchedule> schedules)
        loaded,
    required TResult Function(bool all, Set<(Type, String)> loading) loading,
  }) {
    return loaded(schedulesIndex, schedules);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            @HiveField(0, defaultValue: {})
            Map<(Type, String), BaseSchedule> schedulesIndex,
            @HiveField(1, defaultValue: {})
            Map<(Type, String), ExtendedSchedule> schedules)?
        loaded,
    TResult? Function(bool all, Set<(Type, String)> loading)? loading,
  }) {
    return loaded?.call(schedulesIndex, schedules);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            @HiveField(0, defaultValue: {})
            Map<(Type, String), BaseSchedule> schedulesIndex,
            @HiveField(1, defaultValue: {})
            Map<(Type, String), ExtendedSchedule> schedules)?
        loaded,
    TResult Function(bool all, Set<(Type, String)> loading)? loading,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(schedulesIndex, schedules);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Loading value) loading,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Loading value)? loading,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Loading value)? loading,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _Loaded extends ScheduleManagerState {
  factory _Loaded(
      {@HiveField(0, defaultValue: {})
      final Map<(Type, String), BaseSchedule> schedulesIndex,
      @HiveField(1, defaultValue: {})
      final Map<(Type, String), ExtendedSchedule> schedules}) = _$LoadedImpl;
  _Loaded._() : super._();

  @HiveField(0, defaultValue: {})
  Map<(Type, String), BaseSchedule> get schedulesIndex;
  @HiveField(1, defaultValue: {})
  Map<(Type, String), ExtendedSchedule> get schedules;
  @JsonKey(ignore: true)
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool all, Set<(Type, String)> loading});
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$ScheduleManagerStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? all = null,
    Object? loading = null,
  }) {
    return _then(_$LoadingImpl(
      all: null == all
          ? _value.all
          : all // ignore: cast_nullable_to_non_nullable
              as bool,
      loading: null == loading
          ? _value._loading
          : loading // ignore: cast_nullable_to_non_nullable
              as Set<(Type, String)>,
    ));
  }
}

/// @nodoc

class _$LoadingImpl extends _Loading with DiagnosticableTreeMixin {
  _$LoadingImpl(
      {this.all = false, final Set<(Type, String)> loading = const {}})
      : _loading = loading,
        super._();

  @override
  @JsonKey()
  final bool all;
  final Set<(Type, String)> _loading;
  @override
  @JsonKey()
  Set<(Type, String)> get loading {
    if (_loading is EqualUnmodifiableSetView) return _loading;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_loading);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ScheduleManagerState.loading(all: $all, loading: $loading)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ScheduleManagerState.loading'))
      ..add(DiagnosticsProperty('all', all))
      ..add(DiagnosticsProperty('loading', loading));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadingImpl &&
            (identical(other.all, all) || other.all == all) &&
            const DeepCollectionEquality().equals(other._loading, _loading));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, all, const DeepCollectionEquality().hash(_loading));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadingImplCopyWith<_$LoadingImpl> get copyWith =>
      __$$LoadingImplCopyWithImpl<_$LoadingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            @HiveField(0, defaultValue: {})
            Map<(Type, String), BaseSchedule> schedulesIndex,
            @HiveField(1, defaultValue: {})
            Map<(Type, String), ExtendedSchedule> schedules)
        loaded,
    required TResult Function(bool all, Set<(Type, String)> loading) loading,
  }) {
    return loading(all, this.loading);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            @HiveField(0, defaultValue: {})
            Map<(Type, String), BaseSchedule> schedulesIndex,
            @HiveField(1, defaultValue: {})
            Map<(Type, String), ExtendedSchedule> schedules)?
        loaded,
    TResult? Function(bool all, Set<(Type, String)> loading)? loading,
  }) {
    return loading?.call(all, this.loading);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            @HiveField(0, defaultValue: {})
            Map<(Type, String), BaseSchedule> schedulesIndex,
            @HiveField(1, defaultValue: {})
            Map<(Type, String), ExtendedSchedule> schedules)?
        loaded,
    TResult Function(bool all, Set<(Type, String)> loading)? loading,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(all, this.loading);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Loading value) loading,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Loading value)? loading,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Loading value)? loading,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading extends ScheduleManagerState {
  factory _Loading({final bool all, final Set<(Type, String)> loading}) =
      _$LoadingImpl;
  _Loading._() : super._();

  bool get all;
  Set<(Type, String)> get loading;
  @JsonKey(ignore: true)
  _$$LoadingImplCopyWith<_$LoadingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
